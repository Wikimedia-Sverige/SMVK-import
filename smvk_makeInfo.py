#!/usr/bin/python
# -*- coding: utf-8  -*-
"""
Construct image information templates and categories for SMVK data.

These templates are always Photograph independent on the image type.

Transforms the csv data into a BatchUploadTools compliant json file.
"""
from collections import OrderedDict
from datetime import datetime

import pywikibot

import batchupload.common as common
import batchupload.helpers as helpers
import batchupload.listscraper as listscraper
from batchupload.make_info import MakeBaseInfo

import SMVKMappingUpdater as mapping_updater

MAPPINGS_DIR = 'mappings'
BATCH_CAT = 'Media_contributed_by_SMVK'  # stem for maintenance categories
BATCH_DATE = '2018-02'  # branch for this particular batch upload
LOGFILE = 'smvk_processing.log'
GEO_ORDER = ('other_geo', 'ort', 'region', 'land')
DATA_FILE = 'smvk_data.csv'


class SMVKInfo(MakeBaseInfo):
    """Construct descriptions + filenames for a Nordic Museum batch upload."""

    def __init__(self, **options):
        """Initialise a make_info object."""
        batch_date = common.pop(options, 'batch_label') or BATCH_DATE
        batch_cat = common.pop(options, 'base_meta_cat') or BATCH_CAT
        #pop archive_card filename, store and later store the data
        super(SMVKInfo, self).__init__(batch_cat, batch_date, **options)

        # black-listed values
        #self.bad_names = ('Nordiska museets arkiv', )
        #self.bad_dates = ('odaterad', )

        self.commons = pywikibot.Site('commons', 'commons')
        self.wikidata = pywikibot.Site('wikidata', 'wikidata')
        self.category_cache = {}  # cache for category_exists()
        self.wikidata_cache = {}  # cache for Wikidata results
        self.log = common.LogFile('', LOGFILE)
        self.log.write_w_timestamp('Make info started...')
        self.pd_year = datetime.now().year - 70

    def load_data(self, in_file):
        """
        Load the provided csv data.

        Return this as a dict with an entry per file which can be used for
        further processing.

        :param in_file: the path to the metadata file generated by harvester
        :return: dict
        """
        return mapping_updater.load_data(in_file)
        #also load archive_card data

    def load_mappings(self, update_mappings):
        """
        Update mapping files, load these and package appropriately.

        :param update_mappings: whether to first download the latest mappings
        """
        self.mappings = mapping_updater.load_mappings(
            update_mappings,
            load_mapping_lists='Commons:Världskulturmuseerna/mapping')

    def mapped_and_wikidata(self, entry, mapping):
        """Add the linked wikidata info to a mapping."""
        if entry in mapping:
            mapped_info = mapping.get(entry)
            if mapped_info.get('wikidata'):
                mapped_info.update(
                    self.get_wikidata_info(mapped_info.get('wikidata')))
            return mapped_info
        return {}

    def process_data(self, raw_data):
        """
        Take the loaded data and construct a NMItem for each.

        Populates self.data but filters out, and logs, any problematic entries.

        :param raw_data: output from load_data()
        """
        self.data = {key: SMVKItem(value, self)
                     for key, value in raw_data.items()}

        # remove all problematic entries
        problematic = list(
            filter(lambda x: self.data[x].problems, self.data.keys()))
        for key in problematic:
            item = self.data.pop(key)
            text = '{0} -- image was skipped because of: {1}'.format(
                item.db_id, '\n'.join(item.problems))
            pywikibot.output(text)
            self.log.write(text)

    def generate_filename(self, item):
        """
        Given an item (dict) generate an appropriate filename.

        The filename has the shape: descr - Collection - id
        and does not include filetype

        :param item: the metadata for the media file in question
        :return: str
        """
        return helpers.format_filename(
            item.get_title_description(), 'SMVK', item.photo_id)

    def make_info_template(self, item):
        """
        Given an item of any type return the filled out template.

        :param item: the metadata for the media file in question
        :return: str
        """
        if item.creator:
            return self.make_artwork_info(item)
        else:
            return self.make_photograph_template(item)

    def make_photograph_template(self, item):
        """
        Create the Photograph template for a single SMVK entry.

        :param item: the metadata for the media file in question
        :return: str
        """
        template_name = 'Photograph'
        template_data = OrderedDict()
        template_data['photographer'] = item.get_creator()  #verify
        template_data['title'] = ''
        template_data['description'] = item.get_description()
        template_data['original description'] = item.get_original_description()
        template_data['depicted people'] = item.get_depicted_object(
            typ='person')  #verify
        template_data['depicted place'] = item.get_depicted_place()  #verify
        template_data['date'] = item.get_creation_date()  #verify
        template_data['institution'] = (
            '{{Institution:Statens museer för världskultur}}')
        template_data['department'] = item.get_museum()
        template_data['references'] = item.get_references()
        template_data['notes'] = item.get_notes()  #verify
        template_data['accession number'] = item.get_id_link()  #verify
        template_data['source'] = item.get_source()
        template_data['permission'] = item.get_license_text()  #verify
        template_data['other_versions'] = ''

        return helpers.output_block_template(template_name, template_data, 0)

    def make_artwork_info(self, item):
        """
        Create the Artwork template for a single SMVK entry.

        :param item: the metadata for the media file in question
        :return: str
        """
        raise NotImplementedError

    def generate_content_cats(self, item):
        """
        Extract any mapped keyword categories or depicted categories.

        :param item: the NMItem to analyse
        :return: list of categories (without "Category:" prefix)
        """
        item.make_item_keyword_categories()  #verify

        # Add parish/municipality categorisation when needed
        if item.needs_place_cat:  #verify
            item.make_place_category()  #verify

        return list(item.content_cats)  #verify

    def generate_meta_cats(self, item, content_cats):
        """
        Produce maintenance categories related to a media file.

        :param item: the metadata for the media file in question
        :param content_cats: any content categories for the file
        :return: list of categories (without "Category:" prefix)
        """
        cats = set([self.make_maintenance_cat(cat) for cat in item.meta_cats])

        cats.add(self.batch_cat)

        # problem cats
        if not content_cats:
            cats.add(self.make_maintenance_cat('needing categorisation'))
        # @todo any others?

        # creator cats are classified as meta
        creator_cats = item.get_creator_cat()
        for creator_cat in creator_cats:
            cats.add(creator_cat)

        return list(cats)

    def get_wikidata_info(self, qid):
        """
        Wrap listscraper.get_wikidata_info with local variables.

        :param qid: Qid for the Wikidata item
        :return: bool
        """
        return listscraper.get_wikidata_info(
            qid, site=self.wikidata, cache=self.wikidata_cache)

    def category_exists(self, cat):
        """
        Wrap helpers.self.category_exists with local variables.

        :param cat: category name (with or without "Category" prefix)
        :return: bool
        """
        return helpers.category_exists(
            cat, site=self.commons, cache=self.category_cache)

    # @todo update
    @classmethod
    def main(cls, *args):
        """Command line entry-point."""
        usage = (
            'Usage:'
            '\tpython smvk_makeInfo.py -in_file:PATH -dir:PATH\n'
            '\t-in_file:PATH path to metadata file created by harvester\n'
            '\t-dir:PATH specifies the path to the directory containing a '
            'user_config.py file (optional)\n'
            '\t-update_mappings:BOOL if mappings should first be updated '
            'against online sources (defaults to True)\n'
        )
        info = super(SMVKInfo, cls).main(usage=usage, *args)
        if info:
            info.log.write_w_timestamp('...Make info finished\n')
            pywikibot.output(info.log.close_and_confirm())


class SMVKItem(object):
    """Store metadata and methods for a single media file."""

    def __init__(self, initial_data, smvk_info):
        """
        Create a SMVKItem item from a dict where each key is an attribute.

        :param initial_data: dict of data to set up item with
        :param smvk_info: the SMVKInfo instance creating this SMVKItem
        """
        for key, value in initial_data.items():
            setattr(self, key, value)

        self.museum = 'VMK'  #temporarily hardcoded
        self.problems = []  # any reasons for not uploading the image
        self.content_cats = set()  # content relevant categories without prefix
        self.meta_cats = set()  # meta/maintenance proto categories
        self.needs_place_cat = True  # if item needs categorisation by place
        self.smvk_info = smvk_info
        self.log = smvk_info.log
        self.commons = smvk_info.commons
        self.description_clean = self.clean_description()
        self.geo_data = self.get_geo_data()

    def clean_description(self):
        """Remove meta info from description string."""
        raise NotImplementedError
        # strip whitespace and trailing , or .
        # log problem if end result is empty

    def get_title_description(self):
        """Construct an appropriate description for a filename."""
        # self.description_clean. self.ort, self.land
        txt = self.description_clean
        if self.ort or self.land:
            txt += '. {}'.format(', '.join(self.ort))
            if self.ort and self.land:
                txt += '; '
            txt += self.land
        return txt

    def get_original_description(self):
        """Given an item get an appropriate original description."""
        raise NotImplementedError
        #  <sv_description><br />
        # ''Plats:'' <Geografiskt namn, annat> (ort; region; land)<br />
        # ''Etnisk grupp:'' <Etnisk grupp> (<Etn, tidigare>)<br />
        # ''Nyckelord:'' <Motivord><br />
        # ''Sökord:'' <Sökord>

    def get_id_link(self):
        """Create the id link template."""
        return '{{SMVK-%s-link|%s|%s}}' % (
            self.museum, self.db_id, self.photo_id)

    def get_museum(self):
        """."""
        qid = self.smvk_info.mappings.get('museums').get(self.museum)
        if not qid:
            self.problems.append(
                '"{}" is an unmatched museum.'.format(self.museum))
        return '{{Item|%s}}' % qid

    def get_source(self):
        """Produce a linked source statement."""
        filename = '{}.tif'.format(self.photo_id)
        template = '{{SMVK cooperation project|museum=%s}}' % self.museum
        return ('The original image file was received from SMVK with the '
                'following filename: {filename}\n{template}'.format(
                    filename=filename, template=template))

    def get_event_data(self):
        """Return data about the event."""
        return self.smvk_info.mappings.get('expeditions').get(self.event)

    def get_description(self, with_depicted=False):
        """
        Given an item get an appropriate description in Swedish and English.

        :param with_depicted: whether to also include depicted data
        """
        sv_desc = '{}. '.format(self.description_clean)
        en_desc = ('{}. '.format(self.description_en.strip().rstrip(' .,'))
                   ).lstrip(' .')
        if self.ethnic:
            sv_desc += '{}. '.format(self.ethnic)
            qid = self.smvk_info.mappings.get('ethnic').get(self.ethnic)
            if qid:
                en_desc += '{{Item|%s}}. ' % qid
        sv_desc += ('{}. '.format(self.get_geo_string())).lstrip(' .')
        if self.event:
            event = self.get_event_data()
            sv_desc += '{}. '.format(event.get('sv'))
            en_desc += '{}. '.format(event.get('en'))

        desc = '{{sv|%s}}\n{{en|%s}}' % (sv_desc, en_desc)
        if with_depicted:
            desc += '\n{}'.format(self.get_depicted_place(wrap=True))

        return desc.strip()

    def get_geo_string(self):
        """Return a sting of the original geodata."""
        raise NotImplementedError

    def get_references(self):
        """Return a combination of the two reference types."""
        refs = set()
        if self.reference_source:
            refs.add(self.reference_source)
        if self.reference_published:
            refs.add(self.reference_published)
        if len(refs) == 1:
            return refs.pop()
        return '* {}'.format('\n* '.join(refs)).strip().rstrip('*')
